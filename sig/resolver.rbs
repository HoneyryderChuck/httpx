module HTTPX
  type ipaddr = String | IPAddr | Resolv::IPv4 | Resolver::Entry

  module Resolver
    type dns_resource = singleton(Resolv::DNS::Resource)

    type dns_result = { "name" => String, "TTL" => Numeric, "alias" => String }
                    | { "name" => String, "TTL" => Numeric, "data" => String }

    RESOLVE_TIMEOUT: Array[Integer]
    MAX_CACHE_SIZE: Integer

    self.@lookup_mutex: Thread::Mutex
    self.@lookups: Hash[String, Array[dns_result]]
    self.@identifier_mutex: Thread::Mutex
    self.@identifier: Integer
    self.@hosts_resolver: Resolv::Hosts
    self.@hostnames: Array[String]

    type dns_decoding_response = [:ok, Array[dns_result]] | [:decode_error, Resolv::DNS::DecodeError] | [:retriable_error | :dns_error, Integer] | Symbol

    def self?.nolookup_resolve: (String hostname) -> Array[Entry]?

    def self?.ip_resolve: (String hostname) -> Array[Entry]?

    def self?.hosts_resolve: (String hostname) -> Array[Entry]?

    def self?.supported_ip_families: () -> Array[ip_family]

    def self?.resolver_for: (Symbol | singleton(Resolver) resolver_type, Options options) -> singleton(Resolver)

    def self?.cached_lookup: (String hostname) -> Array[Entry]?

    def self?.cached_lookup_set: (String hostname, ip_family family, Array[dns_result] addresses) -> void

    def self?.cached_lookup_evict: (String hostname, _ToS ip) -> void

    def self?.lookup: (String hostname, Hash[String, Array[dns_result]] lookups, Numeric ttl) -> Array[Entry]?

    def self?.generate_id: () -> Integer

    def self?.encode_dns_query: (String hostname, ?type: dns_resource, ?message_id: Integer) -> String

    def self?.decode_dns_answer: (String) -> dns_decoding_response

    def self?.lookup_synchronize: [U] () { (Hash[String, Array[dns_result]] lookups, Array[String] hostnames) -> U } -> U

    def self?.id_synchronize: () { () -> void } -> void
  end
end