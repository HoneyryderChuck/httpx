module HTTPX
  type ipaddr = IPAddr | String

  module Resolver
    RESOLVE_TIMEOUT: Array[Integer]

    @lookup_mutex: Thread::Mutex

    type dns_resource = singleton(Resolv::DNS::Resource)

    type dns_result = { "name" => String, "TTL" => Numeric, "alias" => String }
                    | { "name" => String, "TTL" => Numeric, "data" => String }

    type dns_decoding_response = [:ok, Array[dns_result]] | [:decode_error, Resolv::DNS::DecodeError] | [:dns_error, Integer] | Symbol

    def nolookup_resolve: (String hostname) -> Array[IPAddr]

    def ip_resolve: (String hostname) -> Array[IPAddr]?

    def system_resolve: (String hostname) -> Array[IPAddr]?

    def self?.resolver_for: (:native resolver_type) -> singleton(Native) |
                            (:system resolver_type) -> singleton(System) |
                            (:https resolver_type) -> singleton(HTTPS) |
                            [U] (U resolver_type) -> U

    def self?.cached_lookup: (String hostname) -> Array[IPAddr]?

    def self?.cached_lookup_set: (String hostname, ip_family family, Array[dns_result] addresses) -> void

    def self?.lookup: (String hostname, Numeric ttl) -> Array[IPAddr]?

    def self?.generate_id: () -> Integer

    def self?.encode_dns_query: (String hostname, ?type: dns_resource, ?message_id: Integer) -> String

    def self?.decode_dns_answer: (String) -> dns_decoding_response
  end
end