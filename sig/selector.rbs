module HTTPX
  interface _Selectable
    def state: () -> Symbol

    def to_io: () -> IO

    def call: () -> void

    def interests: () -> io_interests?

    def timeout: () -> Numeric?

    def handle_socket_timeout: (Numeric interval) -> void
  end

  class Selector
    type selectable = Resolver::Resolver | Connection | (Object & _Selectable)

    type io_select_selectable = (selectable | Array[selectable])?

    include _Each[selectable]

    extend Forwardable

    READABLE: Array[io_interests]
    WRITABLE: Array[io_interests]

    @timers: Timers

    @selectables: Array[selectable]
    @is_timer_interval: bool

    def next_tick: () -> void

    def terminate: () -> void

    def find_resolver: (Options options) -> Resolver::Resolver?

    def find_connection: (http_uri request_uri, Options options) -> Connection?

    def each_connection: () { (Connection) -> void} -> void
                       | () -> Enumerable[Connection]

    def find_mergeable_connection: (Connection connection) -> Connection?

    def empty?: () -> bool

    def register: (selectable io) -> void

    def deregister: (selectable io) -> selectable?

    private

    def initialize: () -> void

    def select: (Numeric? interval) { (selectable) -> void } -> void

    def select_many: (io_select_selectable r, io_select_selectable w, Numeric? interval) { (selectable) -> void } -> void

    def select_one: (selectable io, io_interests interests, Numeric? interval) { (selectable) -> void } -> void

    def next_timeout: () -> Numeric?
  end

  type io_interests = :r | :w | :rw
end