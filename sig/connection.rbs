module HTTPX
  class Connection

    type protocol = HTTP1 | HTTP2 | _HandshakeHandler

    interface _HandshakeHandler
      def on: (Symbol) { (*untyped) -> void } -> void
      def empty?: () -> bool
      def close: () -> void
      def consume: () -> void
      def <<: (string) -> void
    end

    extend Forwardable
    include Loggable
    include Callbacks
    include HTTPX::Registry[String, Class]

    BUFFER_SIZE: Integer

    @io: TCP

    attr_reader origin: URI::Generic
    attr_reader state: Symbol
    attr_reader pending: Array[Request]
    attr_reader options: Options

    def addresses: () -> Array[ipaddr]?

    def addresses=: (Array[ipaddr]) -> void

    def match?: (URI::Generic, options) -> bool

    def mergeable?: (Connection) -> bool

    def coalescable?: (Connection) -> bool

    def create_idle: (options) -> Connection
                   | () -> Connection

    def merge: (Connection) -> void

    def purge_pending: () { (Request) -> void } -> void

    def match_altsvcs?: (URI::Generic uri) -> bool

    def connecting?: () -> bool
    def inflight?: () -> boolish

    def interests: () -> io_interests?

    def to_io: () -> _ToIO

    def call: () -> void

    def close: () -> void
    def reset: () -> void

    def send: (Request) -> void

    def timeout: () -> Numeric?

    private

    def initialize: ("tcp" | "unix" | "ssl", URI::Generic, options) -> untyped

    def connect: () -> void

    def exhausted?: () -> boolish

    def consume: () -> void

    def send_pending: () -> void

    def parser: () -> protocol

    def build_parser: () -> protocol
                    | (String) -> protocol

    def set_parser_callbacks: (protocol) -> void

    def transition: (Symbol) -> void

    def handle_response: () -> void

    def on_error: (HTTPX::TimeoutError | Error | StandardError) -> void

    def handle_error: (StandardError) -> void

    def total_timeout: () -> untyped?
    # def total_timeout: () -> Timers::Timer?
    #
    def purge_after_closed: () -> void
  end
end