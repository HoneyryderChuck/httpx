module HTTPX
  module Plugins
    module ResponseCache
      CACHEABLE_VERBS: Array[verb]
      CACHEABLE_STATUS_CODES: Array[Integer]

      def self?.cacheable_response?: (::HTTPX::ErrorResponse | cacheResponse response) -> bool
      def self?.cached_response?: (response response) -> bool

      class Store
        @store: Hash[String, Array[cacheResponse]]

        @store_mutex: Thread::Mutex

        def lookup: (cacheRequest request) -> cacheResponse?

        def cached?: (cacheRequest request) -> boolish

        def cache: (cacheRequest request, cacheResponse response) -> void

        def prepare: (cacheRequest request) -> void

        private

        def match_by_vary?: (cacheRequest request, cacheResponse response) -> bool

        def _get: (cacheRequest request) -> Array[cacheResponse]?

        def _set: (cacheRequest request, cacheResponse response) -> Array[cacheResponse]

        def _memset: (cacheRequest request, *cacheResponse response) -> Array[cacheResponse]
      end

      module InstanceMethods
        @response_cache: Store

        def clear_response_cache: () -> void

        def cacheable_request?: (cacheRequest request) -> bool
      end

      module RequestMethods
        attr_accessor cached_response: cacheResponse?

        @response_cache_key: String

        def response_cache_key: () -> String

        def cacheable_verb?: () -> bool
      end

      module ResponseMethods
        @cache: bool

        def cached?: () -> bool

        def mark_as_cached!: () -> void

        def copy_from_cached!: () -> void

        def fresh?: () -> bool

        def cache_control: () -> Array[String]?

        def vary: () -> Array[String]?

        private

        def age: () -> Integer

        def date: () -> Time
      end


      type cacheRequest = Request & RequestMethods

      type cacheResponse = Response & ResponseMethods
    end

    type sessionResponseCache = Session & ResponseCache::InstanceMethods
  end
end