module HTTPX
  class Options
    # include _ToHash

    WINDOW_SIZE: Integer
    MAX_BODY_THRESHOLD_SIZE: Integer
    CONNECT_TIMEOUT: Integer
    OPERATION_TIMEOUT: Integer
    KEEP_ALIVE_TIMEOUT: Integer
    SETTINGS_TIMEOUT: Integer
    DEFAULT_OPTIONS: Hash[Symbol, untyped]

    type timeout_type = :connect_timeout | :settings_timeout | :operation_timeout | :keep_alive_timeout | :total_timeout
    type timeout = Hash[timeout_type, Numeric]

    def self.new: (?options) -> instance

    def self.def_option: (Symbol, ?String) -> void
                       | (Symbol) { (*nil) -> untyped } -> void
    # headers
    attr_reader uri: URI?

    # headers
    attr_reader headers: Headers?

    # timeout
    attr_reader timeout: timeout

    # http2_settings
    attr_reader http2_settings: Hash[Symbol, Integer | bool]

    # max_concurrent_requests
    attr_reader max_concurrent_requests: Integer?

    # max_requests
    attr_reader max_requests: Integer?

    # window_size
    attr_reader window_size: Integer

    # body_threshold_size
    attr_reader body_threshold_size: Integer

    # transport
    attr_reader transport: String?

    # transport_options
    attr_reader transport_options: Hash[untyped, untyped]?

    # addresses
    attr_reader addresses: Array[ipaddr]?

    # params
    attr_reader params: Transcoder::urlencoded_input?

    # form
    attr_reader form: Transcoder::urlencoded_input?

    # json
    attr_reader json: _ToJson?

    # body
    attr_reader body: bodyIO?

    # body
    attr_reader origin: URI::Generic?

    # ssl

    # http2_settings


    # classes
    attr_reader connection_class: singleton(Connection)

    attr_reader request_class: singleton(Request)

    attr_reader response_class: singleton(Response)

    attr_reader headers_class: singleton(Headers)

    attr_reader request_body_class: singleton(Request::Body)

    attr_reader response_body_class: singleton(Response::Body)

    attr_reader resolver_class: Symbol | Class

    attr_reader ssl: Hash[Symbol, untyped]

    # io
    type io_option = _ToIO | Hash[String, _ToIO]
    attr_reader io: io_option?

    # fallback_protocol
    attr_reader fallback_protocol: String

    # debug
    attr_reader debug: _IOLogger?

    # debug_level
    attr_reader debug_level: Integer

    # persistent
    attr_reader persistent: bool

    # resolver_options
    attr_reader resolver_options: Hash[Symbol, untyped]

    # ip_families
    attr_reader ip_families: Array[ip_family]

    def ==: (untyped other) -> bool
    def merge: (_ToHash[Symbol, untyped] other) -> instance
    def to_hash: () -> Hash[Symbol, untyped]

    private

    REQUEST_IVARS: Array[Symbol]

    def initialize: (?options options) -> untyped

    def __initialize__: (?options options) -> untyped
  end

  type options = Options | Hash[Symbol, untyped]
end
